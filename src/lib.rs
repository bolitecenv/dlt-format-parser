use debug_print::{debug_println};
use std::io::Cursor;
use byteorder::{BigEndian, LittleEndian, ReadBytesExt};
use std::io::Read;
use std::{default, fmt};
use std::sync::Mutex;

mod types;
pub use crate::types::*;

mod service;
pub use crate::service::*;

#[derive(Debug)]
pub struct DltFormat{
    pub standard_header: DltStandardHeader,
    pub standard_header_extra: DltStandardHeaderExtra,
    pub extended_header: DltExtendedHeader,
    pub header_size: usize,
    pub payload: Vec<u8>,
}

fn dlt_standard_header_parser(cursor: &mut Cursor<&[u8]>) -> DltStandardHeader {
    //let mut cursor = Cursor::new(data);

    let htyp = cursor.read_u8().unwrap();
    let mcnt = cursor.read_u8().unwrap();
    let len = cursor.read_u16::<BigEndian>().unwrap();

    DltStandardHeader { htyp, mcnt, len }
}

fn dlt_standard_header_extra_parser(htyp: &DltHTYP, cursor: &mut Cursor<&[u8]>) -> DltStandardHeaderExtra {
    let mut ecu = [0u8; DLT_ID_SIZE];
    let mut seid: u32 = 0;
    let mut tmsp: u32 = 0;

    if htyp.WEID {
        cursor.read_exact(&mut ecu).unwrap();
    }

    if htyp.WSID {
        seid = cursor.read_u32::<BigEndian>().unwrap();
    }

    if htyp.WTMS {
        tmsp = cursor.read_u32::<BigEndian>().unwrap();
    }

    DltStandardHeaderExtra { ecu, seid, tmsp }
}

fn dlt_extended_header_parser(htyp: &DltHTYP , cursor: &mut Cursor<&[u8]>) -> DltExtendedHeader {
    if !htyp.UEH {
        return DltExtendedHeader::default();
    }

    let msin = cursor.read_u8().unwrap();
    let noar = cursor.read_u8().unwrap();
    let mut apid = [0u8; DLT_ID_SIZE];
    cursor.read_exact(&mut apid).unwrap();
    let mut ctid = [0u8; DLT_ID_SIZE];
    cursor.read_exact(&mut ctid).unwrap();

    DltExtendedHeader { msin, noar, apid, ctid }
}

fn dlt_service_parser(cursor: &mut Cursor<Vec<u8>>, len: usize) -> MessageList {
    let mut payload_header = vec![0u8; 6];
    let mut payload = vec![0u8; len];

    match cursor.read_exact(&mut payload_header) {
        Ok(_) => {
            println!("Sucess");
        }
        Err(e) => {
            println!("Error {}", e);
        }
    }
    match cursor.read_exact(&mut payload) {
        Ok(_) => {
            println!("Sucess");
        }
        Err(e) => {
            println!("Error {}", e);
        }
    }

    let message = MessageList::default();
    message
}

fn dlt_standard_header_size() -> usize {
    DLT_STANDARD_HEADER_SIZE
}

fn dlt_standard_header_extra_size(htyp: &DltHTYP) -> usize {
    let mut size = 0;

    if htyp.WEID {
        size += 4;
    }
    if htyp.WSID {
        size += 4;
    }
    if htyp.WTMS {
        size += 4;
    }

    size
}

fn dlt_extended_header_size(htyp: &DltHTYP) -> usize {
    if !htyp.UEH {
        0
    } else {
        DLT_EXTENDED_HEADER_SIZE
    }
}

pub fn find_next_dlt_header(buffer: &[u8], start_offset: usize) -> Option<usize> {
    if buffer.len() < start_offset + DLT_STANDARD_HEADER_SIZE {
        return None;
    }

    for offset in start_offset..=(buffer.len() - DLT_STANDARD_HEADER_SIZE) {
        if is_valid_dlt_header_at_offset(buffer, offset) {
            return Some(offset);
        }
    }
    
    None
}

/// Check if there's a valid DLT header starting at the given offset
fn is_valid_dlt_header_at_offset(buffer: &[u8], offset: usize) -> bool {
    // Ensure we have enough bytes for a standard header
    if buffer.len() < offset + DLT_STANDARD_HEADER_SIZE {
        return false;
    }

    let len = (&buffer[offset + 2..offset + 4]).read_u16::<BigEndian>().unwrap();
    if len > buffer.len() as u16 || len > 4096 {
        return false;
    }

    true
}

pub trait DltParse {
    fn dlt_parse(&self) -> Result<(DltFormat, &[u8]), &[u8]>;
}

impl DltParse for [u8] {
    fn dlt_parse(&self) -> Result<(DltFormat, &[u8]), &[u8]> {
        let mut cursor = Cursor::new(self);

        // Check if there's enough data for the standard header
        if self.len() < DLT_STANDARD_HEADER_SIZE {
            return Err(self);
        }

        // Parse standard header
        let dlt_standard_header: DltStandardHeader = dlt_standard_header_parser(&mut cursor);
        let dlt_message_len = dlt_standard_header.len as usize;

        // Sanity check: DLT message must not be shorter than header size
        if dlt_message_len < DLT_STANDARD_HEADER_SIZE {
            return Err(self);
        }

        // Make sure we have the full message available
        if self.len() < dlt_message_len {
            return Err(self);
        }

        let htyp = dlt_standard_header.get_htyp();

        let dlt_standard_header_extra: DltStandardHeaderExtra =
            dlt_standard_header_extra_parser(&htyp, &mut cursor);

        let dlt_extended_header: DltExtendedHeader =
            dlt_extended_header_parser(&htyp, &mut cursor);

        let current_pos = cursor.position() as usize;
        let payload_len = dlt_message_len - current_pos;

        // Confirm we won't read out of bounds
        if current_pos + payload_len > self.len() {
            return Err(self);
        }

        let mut payload_buf = vec![0u8; payload_len];
        if let Err(_) = cursor.read_exact(&mut payload_buf) {
            return Err(self);
        }

        let headers_size = dlt_standard_header_size()
            + dlt_standard_header_extra_size(&htyp)
            + dlt_extended_header_size(&htyp);

        let dlt_format = DltFormat {
            standard_header: dlt_standard_header,
            standard_header_extra: dlt_standard_header_extra,
            extended_header: dlt_extended_header,
            header_size: headers_size,
            payload: payload_buf,
        };

        // Get remaining bytes after this DLT message
        let remaining = &self[dlt_message_len..];

        Ok((dlt_format, remaining))
    }
}



#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dlt_standard_header_extra_parser() {
        let data: [u8; _] = [
            0x35, 0x00, 0x00, 0x20, 0x45, 0x43, 0x55, 0x31, 0x82, 0x72, 0xD9, 0x99, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x20, 0x45, 0x43, 0x55, 0x31, 0x82, 0x70, 0x6C, 0xAB, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x0E, 0x00, 0x4F, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x82, 0x70, 0x6C, 0xAB, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x23, 0x37, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x2E, 0x20, 0x54, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x3A, 0x20, 0x30, 0x00, 0x3D, 0x0F, 0x00, 0x58, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x82, 0x72, 0xD9, 0x9B, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x38, 0x00, 0x4E, 0x65, 0x77, 0x20, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x23, 0x37, 0x20, 0x65, 0x73, 0x74, 0x61, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x64, 0x2C, 0x20, 0x54, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x3A, 0x20, 0x31, 0x00,
            0x35, 0x00, 0x00, 0x20, 0x45, 0x43, 0x55, 0x31, 0x84, 0xE0, 0xE6, 0x1A, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x20, 0x45, 0x43, 0x55, 0x31, 0x84, 0xD8, 0x90, 0x13, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x02, 0x0F, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x36, 0x00, 0x4F, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x84, 0xD8, 0x90, 0x13, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x23, 0x37, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x64, 0x2E, 0x20, 0x54, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x3A, 0x20, 0x30, 0x00, 0x3D, 0x37, 0x00, 0x58, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x84, 0xE0, 0xE6, 0x1A, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x38, 0x00, 0x4E, 0x65, 0x77, 0x20, 0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x23, 0x37, 0x20, 0x65, 0x73, 0x74, 0x61, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x65, 0x64, 0x2C, 0x20, 0x54, 0x6F, 0x74, 0x61, 0x6C, 0x20, 0x43, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x3A, 0x20, 0x31, 0x00
        ];

        let (dlt_analyzed_data, remaining_data) = match data.dlt_parse() {
            Ok((dlt_data, remaining)) => (dlt_data, remaining),
            Err(_) => {
                panic!("Failed to parse DLT data");
            }
        };

        println!("{:?}", dlt_analyzed_data);

        let expected_header = DltStandardHeader {
            htyp: 53,
            mcnt: 0,
            len: 32, // Note the byte order
        };

        let expected_header_extra = DltStandardHeaderExtra {
            ecu: [0x44, 0x4C, 0x54, 0x31], // "DLT1"
            seid: 1,
            tmsp: 0x12345678,
        };

        let expected_exnteded_header = DltExtendedHeader {
            msin: 38, // "DLT1"
            noar: 1,
            apid: *b"DA1\0",
            ctid: *b"DC1\0",
        };

        assert_eq!(dlt_analyzed_data.standard_header, expected_header);
        assert_eq!(dlt_analyzed_data.extended_header, expected_exnteded_header);
    }

    #[test]
    fn test_dlt_paser_log() {
        let data: [u8; _] = [
            0x3D, 0x12, 0x00, 0x78, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x82, 0xA2, 0xD2, 0xDF, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x58, 0x00, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x49, 0x44, 0x20, 0x27, 0x4C, 0x4F, 0x47, 0x27, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x50, 0x49, 0x44, 0x20, 0x31, 0x36, 0x31, 0x35, 0x32, 0x33, 0x2C, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x54, 0x65, 0x73, 0x74, 0x20, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x4C, 0x6F, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x00, 0x35, 0x00, 0x00, 0x65, 0x45, 0x43, 0x55, 0x31, 0x82, 0xA2, 0xD2, 0xE0, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x4C, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x54, 0x45, 0x53, 0x54, 0xFF, 0xFF, 0x18, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x4C, 0x6F, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x1C, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x4C, 0x6F, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x72, 0x65, 0x6D, 0x6F, 0x35, 0x00, 0x00, 0x68, 0x45, 0x43, 0x55, 0x31, 0x82, 0xA2, 0xD2, 0xE1, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x4C, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x54, 0x53, 0x31, 0x00, 0xFF, 0xFF, 0x1B, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x31, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x6A, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x1C, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x4C, 0x6F, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x72, 0x65, 0x6D, 0x6F, 0x35, 0x00, 0x00, 0x68, 0x45, 0x43, 0x55, 0x31, 0x82, 0xA2, 0xD2, 0xE2, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x01, 0x00, 0x4C, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x54, 0x53, 0x32, 0x00, 0xFF, 0xFF, 0x1B, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x32, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x6A, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x1C, 0x00, 0x54, 0x65, 0x73, 0x74, 0x20, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x4C, 0x6F, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x72, 0x65, 0x6D, 0x6F, 0x3D, 0x00, 0x00, 0x34, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x76, 0xF3, 0x82, 0xA2, 0xD2, 0xDC, 0x31, 0x02, 0x4C, 0x4F, 0x47, 0x00, 0x54, 0x45, 0x53, 0x54, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0C, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00, 0x3D, 0x01, 0x00, 0x34, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x76, 0xF3, 0x82, 0xA2, 0xE6, 0x71, 0x31, 0x02, 0x4C, 0x4F, 0x47, 0x00, 0x54, 0x45, 0x53, 0x54, 0x23, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0C, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00, 0x3D, 0x02, 0x00, 0x34, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x76, 0xF3, 0x82, 0xA2, 0xF9, 0xFD, 0x31, 0x02, 0x4C, 0x4F, 0x47, 0x00, 0x54, 0x45, 0x53, 0x54, 0x23, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0C, 0x00, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x00
        ];

        let (dlt_analyzed_data, remaining_data) = match data.dlt_parse() {
            Ok((dlt_data, remaining)) => (dlt_data, remaining),
            Err(_) => {
                panic!("Failed to parse DLT data");
            }
        };

        //println!("{:?}", dlt_analyzed_data);

        let expected_header = DltStandardHeader {
            htyp: 0x3d,
            mcnt: 18,
            len: 120, // Note the byte order
        };

        let expected_header_extra = DltStandardHeaderExtra {
            ecu: *b"ECU1", // "DLT1"
            seid: 153447,
            tmsp: 2191708895,
        };

        let expected_exnteded_header = DltExtendedHeader {
            msin: 65, // "DLT1"
            noar: 1,
            apid: *b"DLTD",
            ctid: *b"INTM",
        };

        let analyzed_payload = MessageList::parse(&dlt_analyzed_data.payload, dlt_analyzed_data.payload.len());

        let payload = *b"ApplicationID 'LOG' registered for PID 161523, Description=Test Application for Logging";

        assert_eq!(dlt_analyzed_data.standard_header, expected_header);
        assert_eq!(dlt_analyzed_data.standard_header_extra, expected_header_extra);
        assert_eq!(dlt_analyzed_data.extended_header, expected_exnteded_header);
        assert_eq!(analyzed_payload.get_entire_string().as_bytes(), payload);
    }

    #[test]
    fn test_dlt_service_msg() {
        let data: [u8; _] = [
            0x35, 0x00, 0x00, 0x27, 0x45, 0x43, 0x55, 0x31, 0x84, 0xEF, 0x38, 0x78, 0x26, 0x01, 0x44, 0x41, 0x31, 0x00, 0x44, 0x43, 0x31, 0x00, 0x01, 0x0F, 0x00, 0x00, 0x00, 0x4C, 0x4F, 0x47, 0x00, 0x54, 0x45, 0x53, 0x54, 0x72, 0x65, 0x6D, 0x6F, 0x3D, 0x39, 0x00, 0x38, 0x45, 0x43, 0x55, 0x31, 0x00, 0x02, 0x57, 0x67, 0x84, 0xEF, 0x38, 0x79, 0x41, 0x01, 0x44, 0x4C, 0x54, 0x44, 0x49, 0x4E, 0x54, 0x4D, 0x00, 0x02, 0x00, 0x00, 0x18, 0x00, 0x55, 0x6E, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x41, 0x70, 0x49, 0x44, 0x20, 0x27, 0x4C, 0x4F, 0x47, 0x27, 0x00
        ];

        let (dlt_analyzed_data, remaining_data) = match data.dlt_parse() {
            Ok((dlt_data, remaining)) => (dlt_data, remaining),
            Err(_) => {
                panic!("Failed to parse DLT data");
            }
        };

        println!("{:?}", dlt_analyzed_data);

    }
}
